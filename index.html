<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>path on beat</title>
    <style>
        :root { color-scheme: light; }
        html, body { margin: 0; height: 100%; overflow: hidden; background: #000000; }
        canvas { display: block; width: 100vw; height: 100vh; }
        .ui {
            position: fixed; left: 16px; bottom: 16px;
            font: 10px/1.3 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            background: rgba(255, 255, 255, 0.13);
            padding: 12px 12px 10px 12px;
            backdrop-filter: blur(6px);
            max-width: 340px;
            user-select: none;
            color: #ffffff;
        }
        .row label, .row span { color: rgba(255,255,255,0.85); }
        .row { display: flex; align-items: center; gap: 10px; margin: 6px 0; }
        .row label { width: 110px; opacity: 0.8; }
        .row input[type="range"] { width: 180px; }
        .row input[type="checkbox"] { transform: translateY(1px); }
        .hint { margin-top: 8px; opacity: 0.75; }
        .btns { display: flex; gap: 8px; margin-top: 8px; }
        .ui.is-hidden { opacity: 0; pointer-events: none; }
        button {
            border: 1px solid rgba(0,0,0,0.16);
            background: #fff; border-radius: 10px;
            padding: 6px 10px;
            font: inherit;
            cursor: pointer;
        }
        button:active { transform: translateY(1px); }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div class="ui">
        <div class="row">
          <label>Stroke</label>
          <input id="stroke" type="range" min="0.5" max="8" step="0.1" value="1">
          <span id="strokeVal">1.0</span>
        </div>

        <div class="row">
          <label>Line Style</label>
          <input id="lineStyle" type="range" min="0" max="4" step="1" value="0">
          <span id="lineStyleVal">Solid</span>
        </div>

        <div class="row">
          <label>Nodes</label>
          <input id="nodes" type="range" min="0" max="60" step="1" value="12">
          <span id="nodesVal">12</span>
        </div>

        <div class="row">
            <label>Node Shape</label>
            <input id="shape" type="range" min="0" max="6" step="1" value="0">
            <span id="shapeVal">Cross</span>
          </div>

        <div class="row">
            <label>Node Size</label>
            <input id="shapeSize" type="range" min="3" max="16" step="1" value="7">
            <span id="shapeSizeVal">7</span>
        </div>

        <div class="row">
          <label>Detail</label>
          <input id="detail" type="range" min="0" max="6" step="1" value="3">
          <span id="detailVal">3</span>
        </div>

        <div class="row">
          <label>Organic</label>
          <input id="organic" type="range" min="0" max="100" step="1" value="100">
          <span id="organicVal">100%</span>
        </div>

        <div class="row">
          <label>Range</label>
          <input id="range" type="range" min="10" max="100" step="1" value="80">
          <span id="rangeVal">80%</span>
        </div>

        <div class="row">
          <label>Tempo</label>
          <input id="speed" type="range" min="40" max="180" step="1" value="90">
          <span id="speedVal">90 BPM</span>
        </div>

        <div class="row">
          <label>Beat Strength</label>
          <input id="beatStrength" type="range" min="0" max="100" step="1" value="70">
          <span id="beatStrengthVal">70%</span>
        </div>

        <div class="row">
          <label>Beat Mode</label>
          <input id="beatMode" type="range" min="0" max="3" step="1" value="0">
          <span id="beatModeVal">4/4</span>
        </div>


        <div class="row">
          <label>Fill</label>
          <input id="fill" type="checkbox">
        </div>

        <div class="row">
          <label>Distance/Location</label>
          <input id="labels" type="checkbox">
        </div>

        <div class="row">
            <label>Theme</label>
            <input id="theme" type="checkbox" checked>
            <span>Dark</span>
          </div>

        <div class="btns">
          <button id="regen">Regenerate</button>
          <button id="pause">Pause</button>
          <button id="download">Download</button>
          <button id="record">Start</button>
        </div>

        <div class="hint">
          Keys: <b>R</b> regenerate · <b>Space</b> pause · <b>H</b> hide panel
        </div>
      </div>

<script>
let FG = "#ffffff";
let BG = "#000000";
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const elRecord = document.getElementById("record");

let width, height;
let pathPoints = []; 
let anchors = [];    
let markers = []; 
let maxMarkers = 12;
let paused = false;
let timeSec = 0;
let lastTime = performance.now();
let isRecording = false;

let mediaRecorder;
let recordedChunks = [];

elRecord.addEventListener("click", () => {
    if (isRecording && mediaRecorder && mediaRecorder.state !== "inactive") {
        mediaRecorder.stop();
        return;
    }

    recordedChunks = [];
    const stream = canvas.captureStream(60);
    mediaRecorder = new MediaRecorder(stream, {
        mimeType: "video/webm; codecs=vp9"
    });

    mediaRecorder.ondataavailable = e => {
        if (e.data.size > 0) recordedChunks.push(e.data);
    };

    mediaRecorder.onstop = () => {
        const blob = new Blob(recordedChunks, { type: "video/webm" });
        const url = URL.createObjectURL(blob);

        const a = document.createElement("a");
        a.href = url;
        a.download = `dot10_motion_${Date.now()}.webm`;
        a.click();

        URL.revokeObjectURL(url);
        isRecording = false;
        elRecord.textContent = "Start";
    };

    mediaRecorder.start();
    isRecording = true;
    elRecord.textContent = "Stop";
});

const ui = {
    stroke: document.getElementById("stroke"),
    strokeVal: document.getElementById("strokeVal"),
    lineStyle: document.getElementById("lineStyle"),
    lineStyleVal: document.getElementById("lineStyleVal"),
    nodes: document.getElementById("nodes"),
    nodesVal: document.getElementById("nodesVal"),
    detail: document.getElementById("detail"),
    detailVal: document.getElementById("detailVal"),
    organic: document.getElementById("organic"),
    organicVal: document.getElementById("organicVal"),
    range: document.getElementById("range"),
    rangeVal: document.getElementById("rangeVal"),
    speed: document.getElementById("speed"),
    speedVal: document.getElementById("speedVal"),
    beatStrength: document.getElementById("beatStrength"),
    beatStrengthVal: document.getElementById("beatStrengthVal"),
    beatMode: document.getElementById("beatMode"),
    beatModeVal: document.getElementById("beatModeVal"),
    shape: document.getElementById("shape"),
    shapeVal: document.getElementById("shapeVal"),
    shapeSize: document.getElementById("shapeSize"),
    shapeSizeVal: document.getElementById("shapeSizeVal"),
    fill: document.getElementById("fill"),
    labels: document.getElementById("labels"),
    regen: document.getElementById("regen"),
    pause: document.getElementById("pause"),
    download: document.getElementById("download"),
    theme: document.getElementById("theme")
};

function syncUI() {
    ui.strokeVal.textContent = (+ui.stroke.value).toFixed(1);
    const lineNames = ["Solid", "Particles", "Dashed", "Blocks", "Multi"];
    ui.lineStyleVal.textContent = lineNames[parseInt(ui.lineStyle.value, 10)] || "Solid";
    ui.nodesVal.textContent = ui.nodes.value;
    ui.detailVal.textContent = ui.detail.value;
    ui.organicVal.textContent = `${ui.organic.value}%`;
    ui.rangeVal.textContent = `${ui.range.value}%`;
    ui.speedVal.textContent = `${ui.speed.value} BPM`;
    ui.beatStrengthVal.textContent = `${ui.beatStrength.value}%`;
    const beatNames = ["4/4", "2/3", "6/8", "2/4"];
    ui.beatModeVal.textContent = beatNames[parseInt(ui.beatMode.value, 10)] || "4/4";
    const shapeIdx = parseInt(ui.shape.value, 10);
    const names = ["Cross", "Triangle", "Circle", "Square", "Coda", "Empty Set", "Square Dot"];
    ui.shapeVal.textContent = names[shapeIdx] || "Cross";
    ui.shapeSizeVal.textContent = ui.shapeSize.value;
}

["input","change"].forEach(ev => {
    ui.stroke.addEventListener(ev, syncUI);
    ui.lineStyle.addEventListener(ev, syncUI);
    ui.nodes.addEventListener(ev, syncUI);
    ui.detail.addEventListener(ev, () => { syncUI(); regenerate(); });
    ui.organic.addEventListener(ev, syncUI);
    ui.range.addEventListener(ev, () => { syncUI(); regenerate(); });
    ui.speed.addEventListener(ev, syncUI);
    ui.beatStrength.addEventListener(ev, syncUI);
    ui.beatMode.addEventListener(ev, () => { syncUI(); regenerate(); });
    ui.shape.addEventListener(ev, syncUI);
    ui.shapeSize.addEventListener(ev, syncUI);
    ui.fill.addEventListener(ev, syncUI);
    ui.labels.addEventListener(ev, syncUI);
});
syncUI();

function applyTheme() {
    const dark = ui.theme.checked;

    document.documentElement.style.setProperty("color-scheme", dark ? "dark" : "light");
    BG = dark ? "#000000" : "#ffffff";
    FG = dark ? "#ffffff" : "#000000";

    const panel = document.querySelector(".ui");
    if (panel) {
        panel.style.background = dark ? "rgba(255,255,255,0.13)" : "rgba(0,0,0,0.06)";
        panel.style.color = dark ? "#ffffff" : "#000000";
        panel.style.border = dark ? "1px solid rgba(255,255,255,0.15)" : "1px solid rgba(0,0,0,0.12)";
    }

    document.querySelectorAll(".row label, .row span, .hint").forEach(el => {
        el.style.color = dark ? "rgba(255,255,255,0.85)" : "rgba(0,0,0,0.75)";
    });

    document.querySelectorAll("button").forEach(btn => {
        btn.style.background = dark ? "#ffffff" : "#000000";
        btn.style.color = dark ? "#000000" : "#ffffff";
        btn.style.border = dark ? "1px solid rgba(0,0,0,0.16)" : "1px solid rgba(255,255,255,0.2)";
    });

    document.querySelectorAll('input[type="range"]').forEach(r => {
        r.style.background = dark ? "rgba(255,255,255,0.25)" : "rgba(0,0,0,0.18)";
    });

    const themeText = ui.theme?.nextElementSibling;
    if (themeText && themeText.tagName === "SPAN") {
        themeText.textContent = dark ? "Dark" : "Light";
    }
}
applyTheme();
ui.theme.addEventListener("change", applyTheme);

function resize() {
    width = canvas.width = window.innerWidth;
    height = canvas.height = window.innerHeight;
    initAnchors();
}
window.addEventListener('resize', resize);

function initAnchors() {
    anchors = [];
    const detail = parseInt(ui.detail.value, 10);
    const count = detail === 0 ? 2 : Math.round(4 + detail * 2);
    const range = parseFloat(ui.range.value) / 100;
    const areaW = width * range;
    const areaH = height * range;
    const minX = (width - areaW) / 2;
    const minY = (height - areaH) / 2;
    const maxX = minX + areaW;
    const maxY = minY + areaH;
    for (let i = 0; i < count; i++) {
        anchors.push({
            x: minX + Math.random() * (maxX - minX),
            y: minY + Math.random() * (maxY - minY),
            vx: (Math.random() - 0.5) * 5,
            vy: (Math.random() - 0.5) * 5,
            ax: 0,
            ay: 0,
            friction: 0.98 
        });
    }
}

function updateMarkers() {

    maxMarkers = parseInt(ui.nodes.value, 10);
    if (markers.length !== maxMarkers) {
        const next = [];
        for (let i = 0; i < maxMarkers; i++) {
            const ratio = maxMarkers <= 1 ? Math.random() : i / maxMarkers;
            next.push({
                ratio,
                type: Math.floor(Math.random() * 3),
                opacity: 1,
                state: 'stay',
                timer: Math.random() * 100 + 50
            });
        }
        markers = next;
    }

    for (let i = markers.length - 1; i >= 0; i--) {
        let m = markers[i];
        if (m.state === 'stay') {
            m.timer--;
            if (m.timer <= 0) m.state = 'out';
        } else if (m.state === 'out') {
            m.opacity -= 0.03;
            if (m.opacity <= 0) {
                markers.splice(i, 1);
            }
        }
    }
}

function beatFactor(t) {
    const bpm = Math.max(10, parseFloat(ui.speed.value));
    const beatTime = (t * bpm) / 60;
    const strength = Math.max(0, Math.min(1, parseInt(ui.beatStrength.value, 10) / 100));

    const mode = parseInt(ui.beatMode.value, 10);
    const patterns = [
        [2.4, 1.2, 1.4, 1.2],           // 4/4
        [2.2, 1.2, 1.2],               // 2/3 (1 strong, 2-3 light)
        [2.4, 1.0, 0.9, 1.5, 1.0, 0.9], // 6/8 (1 strong, 4 medium)
        [2.4, 1.2]                      // 2/4
    ];
    const pattern = patterns[mode] || patterns[0];
    const beatIndex = Math.floor(beatTime) % pattern.length;
    const beatPhase = beatTime % 1;
    const accent = pattern[beatIndex];
    const hit = beatPhase < 0.14 ? 1 : Math.exp(-8 * (beatPhase - 0.14));
    const pulse = hit * accent;
    const floor = 0.15;
    const raw = floor + pulse;
    return 1 + (raw - 1) * strength;
}

function updatePath(multiplier) {
    pathPoints = [];
    const speed = 0.015 * parseFloat(ui.speed.value) * multiplier;
    const range = parseFloat(ui.range.value) / 100;
    const areaW = width * range;
    const areaH = height * range;
    const minX = (width - areaW) / 2;
    const minY = (height - areaH) / 2;
    const maxX = minX + areaW;
    const maxY = minY + areaH;
    anchors.forEach(p => {
        p.x += p.vx * speed;
        p.y += p.vy * speed;
        if (p.x < minX) { p.x = minX; p.vx = Math.abs(p.vx); }
        if (p.x > maxX) { p.x = maxX; p.vx = -Math.abs(p.vx); }
        if (p.y < minY) { p.y = minY; p.vy = Math.abs(p.vy); }
        if (p.y > maxY) { p.y = maxY; p.vy = -Math.abs(p.vy); }
        p.x = Math.max(0, Math.min(width, p.x));
        p.y = Math.max(0, Math.min(height, p.y));
    });

    const detail = parseInt(ui.detail.value, 10);
    if (detail === 0 && anchors.length >= 2) {
        const p1 = anchors[0];
        const p2 = anchors[1];
        for (let t = 0; t <= 1; t += 0.02) {
            pathPoints.push({
                x: p1.x + (p2.x - p1.x) * t,
                y: p1.y + (p2.y - p1.y) * t
            });
        }
        return;
    }

    const organic = Math.max(0, Math.min(1, parseInt(ui.organic.value, 10) / 100));
    for (let i = 0; i < anchors.length; i++) {
        const p0 = anchors[i === 0 ? anchors.length - 1 : i - 1];
        const p1 = anchors[i];
        const p2 = anchors[(i + 1) % anchors.length];
        const p3 = anchors[(i + 2) % anchors.length];

        for (let t = 0; t <= 1; t += 0.01) {
            const cx = 0.5 * ((2 * p1.x) + (-p0.x + p2.x) * t + (2 * p0.x - 5 * p1.x + 4 * p2.x - p3.x) * t * t + (-p0.x + 3 * p1.x - 3 * p2.x + p3.x) * t * t * t);
            const cy = 0.5 * ((2 * p1.y) + (-p0.y + p2.y) * t + (2 * p0.y - 5 * p1.y + 4 * p2.y - p3.y) * t * t + (-p0.y + 3 * p1.y - 3 * p2.y + p3.y) * t * t * t);
            const lx = p1.x + (p2.x - p1.x) * t;
            const ly = p1.y + (p2.y - p1.y) * t;
            const x = lx + (cx - lx) * organic;
            const y = ly + (cy - ly) * organic;
            pathPoints.push({ x, y });
        }
    }
}

function draw() {
    ctx.fillStyle = BG; 
    ctx.fillRect(0, 0, width, height);

    const style = parseInt(ui.lineStyle.value, 10);
    const strokeW = parseFloat(ui.stroke.value);
    const pts = pathPoints;
    if (pts.length > 1) {
        if (style === 1) {
            const step = Math.max(3, Math.round(10 - strokeW * 2));
            ctx.fillStyle = FG;
            ctx.globalAlpha = 1;
            for (let i = 0; i < pts.length; i += step) {
                const p = pts[i];
                ctx.beginPath();
                ctx.arc(p.x, p.y, strokeW * 0.6, 0, Math.PI * 2);
                ctx.fill();
            }
        } else if (style === 2) {
            ctx.beginPath();
            ctx.strokeStyle = FG;
            ctx.globalAlpha = 1;
            ctx.lineWidth = strokeW;
            ctx.setLineDash([strokeW * 4, strokeW * 3]);
            ctx.moveTo(pts[0].x, pts[0].y);
            pts.forEach(p => ctx.lineTo(p.x, p.y));
            ctx.stroke();
            ctx.setLineDash([]);
        } else if (style === 3) {
            const step = Math.max(3, Math.round(8 - strokeW));
            ctx.fillStyle = FG;
            ctx.globalAlpha = 1;
            const s = strokeW * 1.2;
            for (let i = 0; i < pts.length; i += step) {
                const p = pts[i];
                ctx.fillRect(p.x - s * 0.5, p.y - s * 0.5, s, s);
            }
        } else if (style === 4) {
            ctx.strokeStyle = FG;
            ctx.lineWidth = strokeW * 1.6;
            ctx.globalAlpha = 0.4;
            ctx.beginPath();
            ctx.moveTo(pts[0].x, pts[0].y);
            pts.forEach(p => ctx.lineTo(p.x, p.y));
            ctx.stroke();
            ctx.lineWidth = strokeW;
            ctx.globalAlpha = 1;
            ctx.beginPath();
            ctx.moveTo(pts[0].x, pts[0].y);
            pts.forEach(p => ctx.lineTo(p.x, p.y));
            ctx.stroke();
        } else {
            ctx.beginPath();
            ctx.strokeStyle = FG;
            ctx.globalAlpha = 1;
            ctx.lineWidth = strokeW;
            ctx.moveTo(pts[0].x, pts[0].y);
            pts.forEach(p => ctx.lineTo(p.x, p.y));
            ctx.stroke();
        }
        ctx.globalAlpha = 1;
    }

    markers.forEach(m => {
        let idx = Math.floor(m.ratio * (pathPoints.length - 1));
        let p = pathPoints[idx];
        if (p) {
            drawMarker(p.x, p.y, m.opacity);
        }
    });
}

function drawMarker(x, y, opacity) {
    const s = parseFloat(ui.shapeSize.value);
    ctx.save();
    ctx.globalAlpha = opacity; 
    ctx.strokeStyle = FG;
    ctx.lineWidth = 0.7;
    ctx.fillStyle = FG;
    ctx.font = '10px monospace';

    const shapeIdx = parseInt(ui.shape.value, 10);
    const filled = ui.fill.checked;
    const baseLine = ctx.lineWidth;
    ctx.beginPath();
    if (shapeIdx === 1) {
        ctx.moveTo(x, y - s);
        ctx.lineTo(x + s, y + s);
        ctx.lineTo(x - s, y + s);
        ctx.closePath();
        filled ? ctx.fill() : ctx.stroke();
    } else if (shapeIdx === 2) {
        ctx.arc(x, y, s, 0, Math.PI * 2);
        filled ? ctx.fill() : ctx.stroke();
    } else if (shapeIdx === 3) {
        if (filled) {
            ctx.fillRect(x - s, y - s, s * 2, s * 2);
        } else {
            ctx.strokeRect(x - s, y - s, s * 2, s * 2);
        }
    } else if (shapeIdx === 4) {
        const r = s * 0.9;
        ctx.beginPath();
        ctx.arc(x, y, r, 0, Math.PI * 2);
        filled ? ctx.fill() : ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(x - r * 1.1, y);
        ctx.lineTo(x + r * 1.1, y);
        ctx.moveTo(x, y - r * 1.1);
        ctx.lineTo(x, y + r * 1.1);
        ctx.stroke();
        const dotR = r * 0.18;
        ctx.beginPath();
        ctx.arc(x - r * 1.35, y, dotR, 0, Math.PI * 2);
        ctx.arc(x + r * 1.35, y, dotR, 0, Math.PI * 2);
        ctx.fill();
    } else if (shapeIdx === 5) {
        const r = s * 0.9;
        ctx.beginPath();
        ctx.arc(x, y, r, 0, Math.PI * 2);
        filled ? ctx.fill() : ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(x - r * 0.8, y + r * 0.8);
        ctx.lineTo(x + r * 0.8, y - r * 0.8);
        ctx.stroke();
    } else if (shapeIdx === 6) {
        const r = s * 0.95;
        ctx.strokeRect(x - r, y - r, r * 2, r * 2);
        const inner = r * 0.35;
        ctx.fillRect(x - inner, y - inner, inner * 2, inner * 2);
    } else {
        ctx.moveTo(x - s, y); ctx.lineTo(x + s, y);
        ctx.moveTo(x, y - s); ctx.lineTo(x, y + s);
        ctx.stroke();
    }
    if (ui.labels.checked) {
        ctx.fillText(`${Math.round(x)} ${Math.round(y)}`, x + 10, y - 10);
    }
    ctx.restore();
}

function animate() {
    const now = performance.now();
    const dt = Math.min(0.05, (now - lastTime) / 1000);
    lastTime = now;

    if (!paused) {
        timeSec += dt;
        updatePath(beatFactor(timeSec));
        updateMarkers();
        draw();
    }
    requestAnimationFrame(animate);
}

resize();

function regenerate() {
    initAnchors();
    markers = [];
    pathPoints = [];
}
ui.regen.addEventListener("click", regenerate);

ui.pause.addEventListener("click", () => {
    paused = !paused;
    ui.pause.textContent = paused ? "Play" : "Pause";
});
window.addEventListener("keydown", (e) => {
    if (e.key.toLowerCase() === "r") regenerate();
    if (e.key.toLowerCase() === "h") {
        const panel = document.querySelector(".ui");
        if (panel) panel.classList.toggle("is-hidden");
    }
    if (e.key === " ") {
        e.preventDefault();
        paused = !paused;
        ui.pause.textContent = paused ? "Play" : "Pause";
    }
});

ui.download.addEventListener("click", () => {
    const scale = 2;
    const off = document.createElement("canvas");
    off.width = canvas.width * scale;
    off.height = canvas.height * scale;
    const octx = off.getContext("2d");
    octx.scale(scale, scale);
    octx.drawImage(canvas, 0, 0);

    const link = document.createElement("a");
    const ts = new Date().toISOString().replace(/[:.]/g, "-");
    link.download = `dot10_${ts}_${scale}x.png`;
    link.href = off.toDataURL("image/png", 1.0);
    link.click();
});

animate();
</script>
</body>
</html>
